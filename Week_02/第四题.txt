
Serial GC
单线程的垃圾收集器，不能进行并行处理。此收集器会在自己工作的时候冻结所有应用程序线程，
所以可能不适合服务器环境。它最适合的是简单的命令行程序。

Parallel GC
并行收集器，这是JVM的默认收集器。在年轻代使用 标记-复制（mark-copy）算法，在老年代使用 标记-清除-整理（mark-sweep-compact）算法。
主要目标是增加吞吐量。因为对系统资源的有效使用，能达到更高的吞吐量:
在 GC 期间，所有 CPU 内核都在并行清理垃圾，所以总暂停时间更短；在两次 GC 周期的间隔期，没有 GC 线程在运行，不会消耗任何系统资源。

CMS GC
其对年轻代采用并行 STW 方式的 mark-copy (标记-复制)算法，对老年代主要使用并发 mark-sweep (标记-清除)算法。
CMS GC 的设计目标是避免在老年代垃圾收集时出现长时间的卡顿，主要通过两种手段来达成此
目标：
1. 不对老年代进行整理，而是使用空闲列表（free-lists）来管理内存空间的回收。
2. 在 mark-and-sweep （标记-清除） 阶段的大部分工作和应用线程一起并发执行。
也就是说，在这些阶段并没有明显的应用线程暂停。
但值得注意的是，它仍然和应用线程争抢CPU 时间。默认情况下，CMS 使用的并发线程数等于 CPU 核心数的 1/4。
如果服务器是多核 CPU，并且主要调优目标是降低 GC 停顿导致的系统延迟，那么使用 CMS 是个很明智的选择。
进行老年代的并发回收时，可能会伴随着多次年轻代的 minor GC。


G1 GC

G1 GC 最主要的设计目标是：将 STW 停顿的时间和分布，变成可预期且可配置的。
事实上，G1 GC 是一款软实时垃圾收集器，可以为其设置某项特定的性能指标。为了达成可预期停顿
时间的指标，G1 GC 有一些独特的实现。首先，堆不再分成年轻代和老年代，而是划分为多
个（通常是 2048 个）可以存放对象的 小块堆区域(smaller heap regions)。每个小块，可能一会被
定义成 Eden 区，一会被指定为 Survivor区或者Old 区。在逻辑上，所有的 Eden 区和 Survivor
区合起来就是年轻代，所有的 Old 区拼在一起那就是老年代
这样划分之后，使得 G1 不必每次都去收集整个堆空间，而是以增量的方式来进行处理: 每
次只处理一部分内存块，称为此次 GC 的回收集(collection set)。每次 GC 暂停都会收集所
有年轻代的内存块，但一般只包含部分老年代的内存块。
G1 的另一项创新是，在并发阶段估算每个小堆块存活对象的总数。构建回收集的原则是：垃圾最多的小块会被优先收集。



